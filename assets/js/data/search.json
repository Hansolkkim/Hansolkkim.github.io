[ { "title": "UICollectionView Guide", "url": "/posts/UICollectionView/", "categories": "iOS", "tags": "iOS, UICollectionView", "date": "2022-08-25 17:43:10 +0900", "snippet": "UICollectionView(* CollectionView Programming Guide for iOS의 내용을 정리 및 개인적으로 추가 내용입니다.)UICollectionView? 컬렉션 뷰는 커스텀이 가능한(flexible and changeable) 레이아웃을 사용해 정렬된 data item들을 보여주는 객체입니다. 컬렉션 뷰를 사용하면 시각적 요소의 정확한 레이아웃을 정의할 수 있고, 동적으로 변경할 수도 있습니다. 따라서 Grid, Stack, Circular Layout, Dynamically changing layout 등 생각할 수 있는 모든 형태의 정렬을 구현할 수 있습니다. 컬렉션 뷰는 표시되는 데이터와 해당 데이터를 표시하는데 사용되는 데이터를 엄격하게 구분합니다. 여기서는 1 UICollectionViewCell 객체와 그에 필요한 데이터(DataSource, Delegate) / 2 Layout을 위한 객체를 구분한다는 말인 것 같습니다.컬렉션 뷰는 이 두 데이터를 병합하여 최종 모양을 보여줍니다. You provides the data, the layout object provides the placement information, and the collection view merges the two pieces together to archieve the final appearance. A CollectionView Manages the Visual Presentation of Data-Driven Views 컬렉션 뷰의 유일한 관심사는 뷰를 가져와 특정 방식으로 배치하는 것입니다. 즉, 컬렉션 뷰는 컨텐츠와 관련된 객체가 아니라, 뷰의 Presentation(표시) 및 Arrangement(배치)에 관련된 객체입니다. 컬렉션 뷰를 잘 이용하기 위해서는 CollectionView, Data Source, Layout Object, Custom Object의 관계, 상호 작용을 이해하는 것이 중요합니다. The Flow Layout Supports Grids and Other Line-Oriented Presentations 일반적으로 Flow Layout 객체를 이용해 행, 열을 가지는 Grid를 구현하지만 이를 커스텀한다면 모든 유형의 Linear-Flow를 지원할 수 있습니다. Gesture Recognizers Can Be Used for Cell and Layout Manipulations 다른 여타 뷰들과 마찬가지로 Gesture Recognizer를 컬렉션 뷰에 연결하여 해당 뷰의 컨텐츠를 조작할 수 있습니다. CollectionView Basics 컨텐츠를 화면에 표시하기 위해 컬렉션 뷰는 다양한 객체들과 협력(cooperate)합니다.일부 객체는 앱에서 반드시 제공해주어야 합니다. 예를 들어, 컬렉션 뷰에 표시할 항목 수를 알려주는 데이터 원본 객체를 앱이 제공해주어야 합니다.반드시 제공하지 않아도 될 객체는 UIKit에서 제공하며, 기본적인 컬렉션 뷰 디자인과 관련된 객체입니다. A Collection View Is a Collaboration of Objects 컬렉션 뷰의 디자인은 데이터가 화면에 배열되고 표시되는 방식과 표시되는 데이터를 분리합니다. 아래의 표는 컬렉션 뷰를 구현하기 위해 필요한 클래스, 프로토콜들입니다. 위의 그림은 컬렉션 뷰와 연결된 핵심 객체들 간의 관계를 보여줍니다. 컬렉션 뷰는 DataSource에서 표시할 셀에 대한 데이터를 가져옵니다.DataSource와 Delegate 객체는 Cell Selection, Highlighting 등을 포함하는 컨텐츠를 관리하는 역할을 합니다. 앞서 두 번이나 강조한, 표시되는 데이터를 관리하는 객체입니다. Layout 객체는 Cell들이 속하는 위치를 결정하고 그 정보를 Layout Attribute 객체 형태로 컬렉션 뷰에 알려줍니다. 그런 다음 컬렉션 뷰는 레이아웃 정보를 실제 셀과 병합하여 최종 Visual Presentation을 결정합니다. 해당 과정을 확인하기 위해 커스텀 컬렉션뷰를 작성해 어떤 순서로 컬렉션 뷰가 그려지는지 확인해봤습니다. 가장 먼저 Layout 객체의 prepare() 메소드가 호출됩니다.해당 메소드는 Layout 객체에게 현재 레이아웃을 업데이트하도록 하는 메소드입니다. (레이아웃 업데이트는 컬렉션 뷰가 컨텐츠를 처음 표시할 때와 뷰의 변경으로 인해 레이아웃이 무효화될 때 발생합니다.)레이아웃을 업데이트할 때마다 컬렉션 뷰는 prepare() 를 호출해 Layout 객체에 이후 레이아웃 작업을 준비하도록 합니다.이 메서드의 기본 구현은 아무 작업이 없고, 커스텀 레이아웃을 위해 overriding하여 데이터 구조를 설정하거나 레이아웃을 수행하는데 필요한 초기 계산을 수행하도록 하는 역할을 합니다. (컬렉션 뷰의 사이즈, item의 위치를 결정하기 위한 초기 계산 등을 수행한다고 합니다.) [UICollectionView를 이용한 LINE iOS 대화방 리팩토링] 포스팅에서 확인해보면, 아래와 같이 prepare 함수를 활용했음을 확인할 수 있었습니다. UICollectionViewLayout의 prepare() 함수에서는 UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성을 미리 계산하여 메모리에 적재한 뒤 유지합니다. 레이아웃의 데이터 구조를 설계할 때는, UICollectionView에서 특정 화면 영역이나 특정 IndexPath에 대한 레이아웃 속성을 요청할 때 빠르게 응답할 수 있도록 설계하는 것이 중요합니다. 내부적으로 Dictionary나 Array 등을 활용하여 최대한 빠르게 응답할 수 있도록 설계했습니다. 그 다음 Data Source 객체의 numberOfItemsInSection 관련 메소드가 호출됩니다.섹션마다 몇 개의 item이 필요한지 확인하기 위한 메소드인데, 이는 Layout의 ContentSize를 결정하여 collectionViewContentSize 프로퍼티를 결정하기 위해서 호출됩니다. (ContentSize는 ScrollView에서 스크롤하기 위한 contents의 전체 크기를 위해 필요한 값입니다.)collectionViewContentSize를 알기 위해 item 개수만이 필요한 것은 아니지만, 현재 collectionView를 정의하는 코드에서 itemSize를 결정해주었기 때문에 그 이후의 작업이 진행되었습니다.itemSize를 결정하는 방법에는 Layout.itemSize = ...과 같이 Layout 객체에 직접 정해주는 방법도 있지만 UICollectionViewDelegateFlowLayout 프로토콜의 sizeForItem 관련 메소드를 통해 설정해주는 방법도 있습니다. 하지만 이 방법은 Cell마다 Size가 다를 경우에 필요한 방법입니다. ContentSize를 구하는 과정에서 모든 Cell마다 sizeForItem 메소드를 호출하기 때문에 비효율적이기 때문입니다.따라서 Cell이 모두 같은 Size라면 앞서 말한 첫 번째 방법을 사용하는 것이 효율적이라고 합니다. 그 다음 앞서 말했던 Layout 객체의 ContentSize 결정을 위한 collectionViewContentSize 프로퍼티의 결정이 이루어집니다. 그 이후에 Layout 객체에서 layoutAttributesForElements 메소드를 이용해 각각의 Element 마다 필요한 Attribute를 생성해줍니다. 그리고 Data Source 객체에서 Cell에 표시될 데이터 결정을 위해 cellForItemAt 메소드를 호출합니다. Reusable Views Improve Performance 컬렉션 뷰는 효율성를 개선하기 위해 뷰의 Recycling Program을 사용합니다.뷰가 화면에서 벗어나면 뷰에서 제거되고 (삭제되지는 않고) 재사용 큐에 배치됩니다.새 컨텐츠가 스크롤되어 화면에 나타나면 재사용 큐에 있던 뷰가 큐에서 빠져나와 새 컨텐츠가 되어 그 용도가 변경됩니다. 이런 Recycling을 위해 컬렉션 뷰에 의해 표시되는 모든 뷰들은 UICollectionReusableView클래스의 자식 클래스여야 합니다. 컬렉션 뷰는 Cell, Supplementary View, Decoration View 세 종류의 ReusableView를 제공합니다. (각 용도는 해당 사이트에서 참고하면 될 것 같습니다!) 컬렉션 뷰는 테이블 뷰와는 다르게 Data Source에서 제공하는 Cell, Supplementary Views의 특정 스타일을 사용하지 않습니다.대신 기본 Reusable View Class는 수정할 수 있는 빈 캔버스와 같습니다. 이를 사용하여 뷰 계층 구조를 만들든, 이미지를 표시하든, 컨텐츠를 동적으로 그릴 수 있습니다. DataSource 객체는 연결된 컬렉션 뷰에서 사용하는 Cell, Supplementary View를 제공하는 역할을 하지만 뷰를 직접 생성하지는 않고, 뷰를 요청하면, 데이터 소스는 컬렉션 뷰의 메서드를 사용하여 원하는 유형의 뷰를 큐에서 빼와서 구성하도록 합니다. The Layout Object Controls the Visual Presentation Layout 객체는 컬렉션 뷰 내에서 item의 배치 및 시각적 스타일을 결정하는 단독 책임을 갖습니다.DataSource 객체가 뷰와 실제 컨텐츠를 제공하지만, Layout 객체는 해당 뷰의 크기, 위치 및 기타 모양 관련 속성을 결정합니다.이런 책임 분리 덕분에 데이터 객체를 변경하지 않고도 레이아웃을 동적으로 변경할 수 있습니다. 컬렉션 뷰에서 사용하는 Layout 객체는 실제로 해당 뷰를 소유하지 않기 때문에 관리하는 뷰를 직접적으로(directly) 건드리지 않습니다.대신 컬렉션 뷰에서 Cell, Supplementary View, Decoration View의 위치, 크기 및 시각적 모양을 describe하는 attributes를 생성합니다.그런 다음 attributes를 실제 뷰 객체에 적용하는 것은 컬렉션 뷰의 책임입니다. 위의 그림은 수직 방향 스크롤의 컬렉션 뷰에서 Flow Layout 객체가 Cell, Supplementary View를 정렬하는 방법을 보여줍니다.수직 방향 스크롤 Flow Layout에서 컨텐츠 영역의 Width는 고정된 상태로 유지되고, Height는 컨텐츠를 수용할 수 있도록 커집니다.면적을 계산하기 위해 Layout 객체는 뷰와 Cell을 한 번에 하나씩 배치하고 각각에 가장 적합한 위치를 선택합니다. (참고로 Flow Layout에서는 Cell, Supplementary View의 크기는 Layout 객체나 Delegate를 통해 속성으로 지정됩니다.) Layout 객체는 뷰의 크기나 위치 그 이상을 제어할 수 있습니다. Transparency, 3D 공간에서의 변형, 다른 뷰들과 겹쳐 보이도록 하는 등의 여러 뷰 관련 속성을 지정할 수 있습니다 Designing Your Data Source and Delegate 모든 컬렉션 뷰는 Data Source 객체를 가지고 있습니다.Data Source 객체는 앱이 보여주려고 하는 컨텐츠 그 자체입니다. Data Source는 앱 데이터 모델로부터 만들어진 객체일 수도, 혹은 컬렉션 뷰 컨트롤러일 수도 있습니다. Data Source에 대한 유일한 Requirement는, 그것이 컬렉션 뷰에 필요한 정보를 제공할 수 있어야 한다는 것입니다.(여기서 정보란, 얼마나 많은 item이 있는지 또는 그 item들을 보여줄 때 어떤 뷰들을 사용하는지에 대한 정보 등을 의미합니다.) Delegate 객체는 필수는 아니지만 존재하는 것이 권장되는 객체입니다.Delegate 객체는 컬렉션 뷰를 통해 컨텐츠를 보여주는 것과 상호 작용과 관련된 측면을 관리하는 객체입니다.The Data Source Manages Your Content Data Source 객체는 컬렉션 뷰를 사용해 표시하는 컨텐츠를 관리하는 객체입니다.Data Source 객체는 지원해야 하는 기본 behavior 및 methods를 정의하는 UICollectionViewDataSource 프로토콜을 준수해야 합니다.Data Source의 역할은 다음 질문에 대한 답변을 컬렉션 뷰에 제공하는 것입니다. 몇 개의 Section을 컬렉션 뷰가 포함하나? 주어진 Section에 대해서 Section은 몇 개의 item을 포함하나? 주어진 Section이나 Item에 대해서 대응하는 컨텐츠를 보여주기 위해 어떤 뷰를 사용하나? Section과 Item은 컬렉션 뷰 컨텐츠의 기본 구성 원칙입니다.컬렉션 뷰는 일반적으로 하나 이상의 Section이 있으며, 각 Section에는 차례로 0개 이상의 Item이 포함됩니다.Item은 표시하려는 주요 컨텐츠를 보여주는 반면, Section은 해당 Item들을 논리적 그룹으로 구성합니다. 컬렉션 뷰는 NSIndexPath 객체를 사용해 포함된 데이터를 참조합니다.Item을 찾으려 할 때 컬렉션 뷰는 Layout 객체에서 제공한 Index Path 정보를 사용합니다.Item은 (Section Number, Item Number) 형태의 Index Path를 가지고, Supplementary View나 Decoration View는 (Section Number, Layout 객체가 제공한 어떠한 값) 형태의 Index Path를 가집니다. Data Source 객체에서 Section과 Item을 어떻게 정렬하든지에 관계없이, 해당 Section과 Item의 시각적 Presentation은 Layout 객체에 의해 결정됩니다.위의 그림에서 처럼, 서로 다른 Layout 객체는 Section과 Item을 매우 다른 방식으로 보여줄 수 있습니다.Flow Layout 객체는 이전 Section 아래에 다음 Section이 오는 형태로, 세로로 정렬을 하는 반면, Custom Layout 객체는 Section을 비선형 배열로 배치하는 것을 보아, Data와 Layout의 역할이 분리되어 있음을 다시 한 번 확인할 수 있습니다. Designing Your Data Objects 효율적인 Data Source는 기본 데이터 객체를 구성하는데 이점을 갖기 위해 Section과 Item을 사용합니다. Data를 Section과 Item으로 구성하면 나중에 Data Source methods를 손쉽게 구현할 수 있습니다.또한 Data Source의 Method들은 자주 호출되기 때문에 이런 method들이 데이터를 가능한 한 빨리 추출할 수 있도록 해야합니다. 한 가지 간단한 솔루션은 아래 그림과 같이 data Source가 nested array 집합을 사용하는 것입니다.이 구성에서 상위 배열은 Data Source의 Seciton을 나타내는 하나 이상의 배열이고, 그러면 각 Section 배열에는 해당 Section에 필요한 데이터 Item이 포함됩니다.Section에서 Item을 찾기 위해서는, Section 배열을 검색한 다음 해당 배열에서 Item을 검색하면 됩니다. Telling the Collection View About Your Content 컬렉션 뷰는 Data Source 객체에게 다음과 같은 상황에서 데이터를 요구합니다. 컬렉션 뷰가 처음 화면에 나타날 때 컬렉션 뷰에 다른 Data Source 객체를 할당할 때 컬렉션 뷰의 reloadData() 메소드를 직접 호출할 때 Delegate 객체가 performBatchUpdate:completion 관련 메소드를 실행할 때나 이동, 추가, 삭제 메소드를 실행할 때 위와 같은 상황에서 numberOfSectionInCollectionView: 관련 메소드를 사용해 Section의 개수를 제공하고, collectionView:numberOfItemInSection: 관련 메소드를 사용하여 각 Section에 있는 Item의 개수를 제공합니다. Inserting, Deleting, and Moving Sections and Items하나의 Section이나 Item을 삽입, 삭제 또는 이동하기 위해서는 다음의 단계를 따라야 합니다. Data Source 객체의 데이터를 업데이트 컬렉션 뷰에서의 적절한 메소드 호출컬렉션 뷰에 변경 사항을 알리기 전에 Data Source를 업데이트하는 것이 중요합니다. 컬렉션 뷰의 Method는 Data Source에 현재 적절한 데이터가 있다고 가정하기 때문입니다.그렇지 않으면 컬렉션 뷰가 Data Source에서 잘못된 Item 집합을 받거나, Data Source에 존재하지 않는 항목을 요청하여 앱이 충돌될 수 있습니다.하나의 Item을 Programmitacally하게 추가, 삭제, 이동할 경우, 컬렉션 뷰는 자동으로 해당 변경을 반영하는 애니메이션을 만듭니다.하지만 여러 변경 사항을 함께 애니메이션하려면 블록 내에서 모든 추가, 삭제, 이동 관련 메소드를 호출하고 해당 블록을 performBatchUpdates:completion: 관련 메소드에 전달해야 합니다.이렇게 하면 batch update process가 모든 변경 사항을 동시에 애니메이션으로 만들어 줍니다. 위의 내용을 코드를 짜서 구현해보았습니다. 먼저, 제일 처음 말했던 “컬렉션 뷰에 변경 사항을 알리기 전에 Data Source를 업데이트”하는 부분을 확인해보기 위해 아래의 두 코드로 비교해보았습니다. @IBAction func tapInsertButton(_ sender: UIButton) { let newData = data.randomElement() ?? UIColor.black data.append(newData) let insertingIndexPath = IndexPath(item: data.count - 1, section: 0) collectionView.insertItems(at: [insertingIndexPath]) } @IBAction func tapInsertButton(_ sender: UIButton) { let insertingIndexPath = IndexPath(item: data.count, section: 0) // 오류 발생 // let insertingIndexPath = IndexPath(item: data.count - 1, section: 0) collectionView.insertItems(at: [insertingIndexPath]) let newData = data.randomElement() ?? UIColor.black data.append(newData) } 맨 위의 코드로 실행할 경우, 새로운 Cell이 추가되며 애니메이션까지 잘 나타남을 확인했습니다. 하지만 두 번째 코드로 실행할 경우, IndexPath의 item 매개변수의 값이 data.count 일 경우, Data Source에 data.count 번째 데이터가 없음을 컬렉션 뷰가 알아채어 오류가 발생했고, data.count - 1일 경우 실제 추가된 indexPath와 입력받은 indexPath가 일치하지 않다는 경고가 발생했습니다(이 경우 애니메이션도 활성화되지 않았습니다.). 따라서 원하는 애니메이션을 하고 정상적으로 추가/제거 되도록 하는 로직을 만들기 위해서는 Data Source를 먼저 업데이트하고 그 변경 사항을 컬렉션 뷰에 알려야 함을 확인할 수 있었습니다. 그 다음, 여러 변경 사항을 performBatchUpdate:completion: 관련 메소드에 전달하는 방법을 이용하기 위해 아래와 같은 코드를 작성했습니다. @IBAction func tapUpdateButton(_ sender: UIButton) { let newData = [data.randomElement()!, data.randomElement()!, data.randomElement()!] collectionView.performBatchUpdates { self.data.append(contentsOf: newData) \t\tlet insertingIndexPaths = [ IndexPath(item: data.count, section: 0), IndexPath(item: data.count + 1, section: 0), IndexPath(item: data.count + 2, section: 0) ] self.collectionView.insertItems(at: insertingIndexPaths) self.data.removeFirst() self.data.removeFirst() let deletingIndexPaths = [ IndexPath(item: 0, section: 0), IndexPath(item: 1, section: 0) ] self.collectionView.deleteItems(at: deletingIndexPaths) } } 위처럼, 컬렉션 뷰의 맨 뒤에 3개의 새로운 Cell을 추가하고, 맨 앞의 2개의 Cell을 삭제하는 코드를 작성했는데 오류가 발생했습니다. 추가된 새로운 Cell의 IndexPath를 컬렉션 뷰가 확인하기 전에 (그 뒤에서 이루어질 거라 예상했던) Data Source에서 Cell 데이터의 삭제가 발생했고, 그로 인해 존재하지 않는 IndexPath의 Cell을 추가하려고 한다는, 최종적으로 변경된 IndexPath 정보를 컬렉션 뷰에 알려야 한다는 오류였고, 이를 해결하기 위해 아래처럼 코드를 수정했습니다. @IBAction func tapUpdateButton(_ sender: UIButton) { let newData = [data.randomElement()!, data.randomElement()!, data.randomElement()!] collectionView.performBatchUpdates { self.data.append(contentsOf: newData) \t\tlet insertingIndexPaths = [ IndexPath(item: data.count-2, section: 0), IndexPath(item: data.count-1, section: 0), IndexPath(item: data.count, section: 0) ] self.collectionView.insertItems(at: insertingIndexPaths) self.data.removeFirst() self.data.removeFirst() let deletingIndexPaths = [ IndexPath(item: 0, section: 0), IndexPath(item: 1, section: 0) ] self.collectionView.deleteItems(at: deletingIndexPaths) } } 따라서, 여러 변경 사항을 한꺼번에 적용하기 위해서는 컬렉션 뷰에 변경 사항 적용 후의 최종적인 Data Source에 대한 IndexPath 정보를 알려야함을 확인할 수 있었습니다. 참고 자료[Collection View Programming Guide for iOS][Apple Develper- UICollectionViewLayout][UICollectionView를 이용한 LINE iOS 대화방 리팩토링 - 1]" }, { "title": "CGAffineTransform에 대해", "url": "/posts/CGAffineTransform/", "categories": "iOS", "tags": "iOS, CGAffineTransform", "date": "2022-08-01 22:43:10 +0900", "snippet": "계기토이 프로젝트 진행하면서 Custom View의 이동 방법에 대해 공부하다가 CGAffineTransform에 대해 새로 알게 되었습니다.View를 직접 이동시키기위해서 Constraints를 업데이트하는 방법도 있었고, CGAffineTransform을 이용해 View가 보이는 위치를 바꿔주는 방법도 있었는데, 이번 포스팅에서는 CGAffineTransform에 대해 정리해보고자 합니다.Affine Transform?아핀 변환은 점, 직선, 평면을 보존하는 선형 매핑 방법입니다. (여기서 “보존”이라는 단어의 의미는, 아핀 변환 이후에도 평행한 선들은 평행한 상태로 유지되는 등의 상태를 말하는 것 같습니다.)CGAffineTransform에서 다룰 아핀 변환은 아래와 같은 변환이 있습니다. 아핀 변환 예 변환 행렬 설명 평행이동 \\(\\begin{bmatrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\t_x&amp;t_y&amp;1\\\\ \\end{bmatrix}\\) tx는 x축 방향 변위를, ty는 y축 방향 변위를 나타냄 스케일링 \\(\\begin{bmatrix}s_x&amp;0&amp;0\\\\0&amp;s_y&amp;0\\\\0&amp;0&amp;1\\\\ \\end{bmatrix}\\) sx는 x축에서의 스케일링 인자를, sy는 y축에서의 스케일링 인자를 나타냄. 회전 \\(\\begin{bmatrix}cos(a)&amp;sin(a)&amp;0\\\\-sin(a)&amp;cos(a)&amp;0\\\\0&amp;0&amp;1\\\\ \\end{bmatrix}\\) a는 회전 각도를 나타냄. 위에서 주어진 변환 행렬을 이용해 기존의 점, 직선, 평면을 계산하게 됩니다.기존의 점을 $(x, y, 1)$, 아핀 변환 중 2배 스케일링 변환된 점을 $(x’, y’, 1)$이라고 할 때, $(x’, y’, 1)$은 아래의 수식으로 구할 수 있습니다.\\[(x', y', 1) = (x, y, 1) \\times \\begin{bmatrix}2&amp;0&amp;0\\\\0&amp;2&amp;0\\\\0&amp;0&amp;1\\end{bmatrix}\\\\x' = 2x, \\;\\;\\;y' = 2y\\]CGAffineTransform?Swift에서는 위의 아핀 변환을 CGAffineTransform이라는 Struct를 이용해 제공해줍니다.위에서 알아봤던 변환 행렬을 알 필요 없이 CGAffineTransform 구조체는 초기화 생성자를 이용해 아핀 변환 후 매핑될 좌표를 모두 계산합니다.CGAffineTransform 구조체의 초기화 생성자는 위와 같습니다.초기화 생성자로 아핀 변환 중 rotate, scale, translate 변환을 제공해주는 것을 확인할 수 있습니다.또한 맨 아래 2개의 초기화 생성자를 통해 직접 변환 행렬을 정의해주는 아핀 변환도 가능합니다. 해당 초기화 생성자들의 매개변수는 아래의 변환 행렬을 기준으로 한 매개변수 입니다.\\[\\begin{bmatrix}a&amp;c&amp;0\\\\c&amp;d&amp;0\\\\t_x&amp;t_y&amp;1\\ \\end{bmatrix}\\] init(rotationAngle:) 초기화 생성자 사용 예시 init(rotationAngle: CGFloat) 초기화 생성자의 경우, 매개변수에 회전하고자 하는 회전 각을 넣어주면 됩니다. (제 경우에는 .pi, .pi/4 등과 같은 값을 넣으면 나중에 알아보기 편했습니다.) func rotateButtonDidTap() { if didRotate { UIView.animate(withDuration: 0.5) { self.targetView.transform = CGAffineTransform(rotationAngle: .pi/4) } completion: { [weak self] _ in self?.didRotate = false } } else { UIView.animate(withDuration: 0.5) { self.targetView.transform = .identity } completion: { [weak self] _ in self?.didRotate = true } }} init(scaleX:y:) 초기화 생성자 사용 예시 init(scaleX: CGFloat, y: CGFloat) 초기화 생성자의 경우, 매개변수에 변환하고자 하는 배율을 넣어주면 됩니다. func scaleButtonDidTap() { if didScale { UIView.animate(withDuration: 0.5) { self.targetView.transform = CGAffineTransform(scaleX: 2.0, y: 2.0) } completion: { [weak self] _ in self?.didScale = false } } else { UIView.animate(withDuration: 0.5) { self.targetView.transform = .identity } completion: { [weak self] _ in self?.didScale = true } }} init(translationX:y:) 초기화 생성자 사용 예시 init(translationX: CGFloat, y: CGFloat) 초기화 생성자의 경우, 매개변수에 x, y 축 방향으로 이동하고자 하는 변위만큼의 값을 넣으면 됩니다. func translateButtonDidTap() { if didTranslate { UIView.animate(withDuration: 0.5) { self.targetView.transform = CGAffineTransform(translationX: 40, y: 40) } completion: { [weak self] _ in self?.didTranslate = false } } else { UIView.animate(withDuration: 0.5) { self.targetView.transform = .identity } completion: { [weak self] _ in self?.didTranslate = true } }} 또한 CGAffineTransform 구조체가 제공해주는 타입 프로퍼티에는 identity가 있습니다.해당 프로퍼티는 아핀 변환 이전의 형태로 다시 돌아갈 때 사용하는 프로퍼티입니다. 아래와 같이 사용하면 아핀 변환된 View가 다시 이전의 상태로 돌아갑니다.UIView.animte(withDuration: 0.5) { self.View.transform = .identity}CGAffineTransform 구조체가 제공해주는 인스턴스 메소드는 위와 같습니다.concatenating(_:) 는 여러 CGAffineTransform의 변환 행렬들을 곱하여 새로운 변환 행렬을 가지는 CGAffineTransform을 만들어주는 메소드입니다.행렬의 곱셈은 교환 법칙이 성립하지 않습니다. 따라서 concatenating(_:) 메소드를 이용하여 새로운 변환 행렬을 만들고자 할 때는 CGAffineTransform 객체들의 순서를 생각하여야 합니다.참고 자료[Apple-Developer-CGAffineTransform][MathWorks-Affine Transform]" }, { "title": "Coordinator Pattern", "url": "/posts/Coordinator/", "categories": "iOS", "tags": "iOS, Design Pattern, Coordinator Pattern", "date": "2022-07-25 10:43:10 +0900", "snippet": "계기토이 프로젝트를 진행하면서, 보다 가벼운 ViewController를 만들 필요성을 느껴 Coordinator Pattern을 적용해보고,이를 정리하기 위해 포스팅을 작성합니다.Coordinator Pattern?Coordinator Pattern은 Soroush Khanlou가 2015년에 The Coordinator라는 글을 쓰면서 소개가 됐다고 합니다. One of the biggest problems with the big view controllers is that they entangle your flow logic, view logic, and business logic. - Khanlou Big(Massive) View Controller의 가장 큰 문제 중 하나는 하나의 flow login, view login, 비즈니스 로직이 얽혀있다는 것이다.func tableView(_ tableView: UITableView, didSelecteRowAt indexPath: IndexPath) { let object = self.dataSource[indexPath] let detailViewController = DetailViewController(with: object) self.navigationController?.present( detailViewController, animated: true, completion: nil )}위 코드는 TableView에서 Cell이 터치됐을 때 다른 ViewController를 present하는 메소드입니다. 만약 화면이 많은 상황에서 위와 같은 코드가 존재하게 된다면, 해당 뷰는 재사용할 수 없게 되고, View 객체가 flow logic을 갖게 되어 View 객체의 역할을 벗어나게 됩니다.위 메소드를 가지고 있는 ViewController는 다음에 어떤 ViewController를 호출하고 보여줄 것인지에 대한 flow logic을 알고 있게 되고, 4번째 줄에서는 심지어 부모 ViewController에게 해야하는 일에 대한 정확한 메세지를 보내 지시하고 있습니다.더 큰 문제는, 이런 다음 단계에 대한 flow logic만을 갖고있는 ViewController가 여러 개 있을 수 있다는 것입니다.Khanlou는 이런 문제를 해결하기 위해 ViewController를 더 높은 수준의 객체가 관리하게 되면 많은 이점을 가질 수 있음을 알게 됐고, 이 객체를 Coordinator라고 부르기로 했습니다.즉, Coordinator라는 객체로 ViewController를 소유, 관리하여, ViewController들 간의 결합도를 낮춰주도록 하는 것입니다.ViewController들은 이전에 어떤 VC가 있었고, 다음에 어떤 VC가 올 지 알 필요가 없고, 이런 flow logic을 Coordinator 객체가 관리해줍니다.이렇게 되면 어떤 순서로도 ViewController 전환이 가능해져 ViewController의 재사용이 가능해집니다.Coordinator Pattern 사용해보기Coordinator Pattern을 활용해 HomeViewController에서 포인트 충전 버튼을 눌렀을 때, 등록된 카드가 있다면 포인트 충전 화면으로, 등록된 카드가 없다면 카드 등록 화면으로 이동하는 앱을 간단하게 만들어보도록 하겠습니다. 만들고자 하는 앱의 구조는 아래와 같습니다.1. Coordinator Protocol 만들기먼저, 화면 전환을 위한 Coordinator 객체의 protocol을 만듭니다.protocol Coordinator: AnyObject { var childrenCoordinator: [Coordinator] { get } var navigationController: UINavigationController { get } func start()} 부모 자식 관계를 가지는 Coordinator를 설계하기 떄문에 childrenCoordinator 프로퍼티를 추가합니다. Coodinator는 화면 전환시 기준이 되는 NavigationController를 소유합니다. 부모 Coordinator가 자식 Coordinator를 생성하고 자식 Coordinator의 첫 화면을 띄우기 위해 start() 메소드를 가집니다.2. AppCoordinator 만들기위에서 만든 Coordinator 프로토콜을 채택하는 AppCoordinator를 만듭니다.class AppCoordinator: Coordinator { var childrenCoordinator: [Coordinator] = []\tlet navigationController: UINavigationController init(navigationController: UINavigationController) { self.navigationController = navigationController } func start() { showHomeViewController() }}private extension AppCoordinator { func showHomeViewController() { let homeCoordinator = HomeCoordinator(navigationController: self.navigationController) childrenCoordinator.append(coordinator) coordinator.start() }}3. HomeCoordinator 만들기AppCoordinator는 앱의 전체적인 Coordination을 관장(*)하는 Coordinator라고 가정하고,HomeCoordinator 또한 만들어 줍니다.(*: 여기서는 생략됐지만 로그인 기능이 있다면 LoginCoordinator/ HomeCoordinator로 분기하는 등의 기능을 하는 Coordinator로 사용한다는 뜻입니다.)class HomeCoordinator: Coordinator { // 다른 구현 내용은 생략합니다. func start() { let homeViewController = HomeViewController(navigation: self) navigationController.pushViewController(viewController, animated: true) }}4. HomeViewController 만들기이제 Top-up Button이 있는 HomeViewController를 만들어줄 차례입니다.HomeViewController는 Top-up Button이 눌렸음을 HomeCoordinator에게 알리고,HomeViewController는 해당 노티를 이용해 다음에 어떤 ViewController를 보여줄지 결정합니다.protocol HomeNavigation: AnyObject { func topupButtonDidTap()}class HomeViewController: UIViewController { private lazy var topupButton: UIButton = { ... let button = UIButton(...) button.addTarget(self, action: #selector(topupButtonDidTap), for: .touchUpInside) return button }() private weak var coordinator: HomeNavigation? ...\t @objc private func topupButtonDidTap() { coordinator?.topupButtonDidTap() }}여기서 HomeNavigation이라는 프로토콜을 사용했습니다.HomeViewController가 자신의 Coordinator에게 특정 노티를 보내주기 위해 Coordinator를 알고 있어야 하지만Coordinator의 모든 부분을 알 필요는 없고, 노티를 위한 메소드 정도만 알고 있도록 하기 위해 해당 프로토콜을 사용했습니다.이제 HomeNavigation 프로토콜을 HomeCoordinator가 채택하도록 하여 화면 전환 플로우를 완성합니다.class HomeCoordinator: Coordinator { private var paymentMethodsList: [PaymentMethod] = [] // 다른 구현 내용은 생략합니다.}extension HomeCoordinator: HomeNavigation { func topupButtonDidTap() { let isPaymentMethodsListEmpty = paymentMethodsList.isEmpty if isPaymentMethodsListEmpty { showAddPaymentMethodViewController() } else { showTopupViewController() } }}private extension HomeCoordinator { func showAddPaymentMethodViewController() { } func showTopupViewController() { }}그리고 앱이 시작될 때에 AppCoordinator를 실행시켜주고, AppCoordinator에 대한 참조를 유지하기 위해SceneDelegate를 아래와 같이 설정합니다.class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? private var appCoordinator: Coordinator? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let windowScene = (scene as? UIWindowScene) else { return } let window = UIWindow(windowScene: windowScene) self.window = window let navigationController = UINavigationController() self.window?.rootViewController = navigationController self.appCoordinator = AppCoordinator(navigationController: navigationController) appCoordinator?.start() self.window?.makeKeyAndVisible() }}5. 동작 화면 등록된 카드가 존재할 때 등록된 카드가 존재하지 않을 때 [전체 코드 확인]더 생각해봐야할 점?토이 프로젝트에 Coordinator 패턴을 적용하다보니 생각해볼 부분이 있었습니다.가장 큰 부분은 Coordinator를 나누는 기준을 무엇으로 할 것인가? 에 대한 의문이었습니다.같이 공부하는 지인들과 토론해본 결과, \"뒤로 가기\"가 필요하고, \"뒤로 가기\"의미가 있는 범위의 ViewController 들끼리 하나의 Coordinator에 소속되어 있는게 적절하지 않을까 하는 결론을 내렸습니다.일례로, 구현하진 않았지만 앞서 말했던 내용처럼, 만약 로그인 뷰가 있고 홈 뷰가 있다면 홈 뷰에서 로그인 뷰로 “뒤로 가기”가 필요하지 않고 의미가 있지 않은 범위의 관계이기 때문에 같은 Coordinator에 속할 필요가 없는 뷰들이라고 생각되었습니다.참고자료 [Khanlau - The Coordinator] [iOS: Coordinator Pattern in Swift] " }, { "title": "iOS의 Layout", "url": "/posts/ViewLayout/", "categories": "iOS", "tags": "iOS, View, Layout, Update-Cycle", "date": "2022-06-30 21:43:00 +0900", "snippet": "계기UITableView는 Cell의 Subview들의 Constraints만 잘 잡아주면 Cell의 높이가 동적으로 설정되는 기능을 이용하려 했습니다.그런데 아무리해도 Cell의 높이는 45 point로 그대로였고, 이거 떄문에 2시간동안 Constraints만 엄청 수정했습니다..포기하고 자려고 하다가, 자기 직전에 요즘 버릇인 UIView 내의 layoutSubviews() 메소드에서 Subview들의 Constraints를 잡아주던게 떠올라, Subview들의 Constraints 설정하는 코드를 모두 초기화 생성자로 옮겼더니 그제서야 TableView Cell의 높이가 동적으로 설정되었습니다..(완성된 내 TableView! 다 하고보니 동적 높이 Cell은 필요없었다..)아무튼 layoutSubview() 메소드를 사용해서 문제가 생겼던 탓에, View의 Layout 업데이트 관련 메소드와 View의 Life-Cycle에 관련해 알아보려고 합니다!iOS Layout Demystifying iOS Layout - [1] 포스팅의 일부를 번역했습니다.Update Cycle(업데이트 주기)Update Cycle은 앱이 모든 이벤트 처리 코드를 실행한 후 Main run loop로 컨트롤을 넘겨주는 시점입니다.이 시점에서 시스템은 Layout, Display 및 Constraints를 업데이트하기 시작합니다. 이벤트 handler를 처리하는 동안 View의 변경을 요청한다면, 시스템은 해당 View를 redraw가 필요한 것으로 표시해놓습니다.(the sysytem will mark the view as needing redraw.) 그리고 다음 Update Cycle에서 시스템은 표시된 View들의 변경 사항을 실행합니다.Update Cycle은 60[fps]로 동작하기 때문에 사용자는 UI 업데이트 지연을 느끼지는 못하지만, 이벤트가 처리되는 시점과 해당 뷰를 다시 그리는 시점 사이의 interval 때문에 우리가 원하는 Run Loop의 시점에 뷰가 업데이트되지 않을 수도 있습니다.따라서 Run Loop, Update Cycle 및 UIView의 특정 메소드를 이해하면 이러한 종류의 문제를 방지하거나 디버깅하는데 도움이 될 수 있습니다.Layout뷰의 Layout은 스크린에서 뷰의 size와 position을 의미합니다.UIView는 뷰의 Layout이 변경되었음을 시스템에게 알리는 메소드를 제공할 뿐 아니라, 뷰의 Layout이 다시 계산된 후 수행할 작업을 정의하기 위해 오버라이딩할 수 있는 메서드를 제공합니다.layoutSubviewslayoutSubviews() 메소드는 뷰와 모든 Subview들의 위치 조정(repositioning) 및 크기 조정(resizing)을 처리합니다.해당 메소드는 재귀적으로 해당 뷰의 모든 Subview들의 layoutSubviews() 메소드를 호출하기 때문에 비용이 많이 드는 메소드입니다. 시스템은 뷰의 frame을 다시 계산할 때마다 이 메소드를 호출하기 때문에 frame을 설정하고 위치 및 크기를 조정할 때 이 메서드를 오버라이딩해야 합니다. 그러나 Layout을 업데이트할 때 layoutSubviews() 메소드를 직접 호출하는 것은 금지되어 있습니다. 대신, Run Loop동안 layoutSubviews()의 호출을 트리거하는, layoutSubviews() 자체를 호출하는 것보다 훨씬 비용이 적은 방법들이 있습니다.layoutSubviews() 메소드가 완료되면 viewDidLayoutSubviews() 메소드에 대한 호출이 해당 뷰를 소유한 뷰 컨트롤러에서 트리거됩니다. layoutSubviews()는 뷰의 Layout이 업데이트된 후 안정적으로 호출되는 유일한 메소드이므로, Layout 및 Sizing에 따라 달라지는 모든 로직을 viewDidLoad()/ viewWillAppear()가 아니라, viewDidLayoutSubviews()에서 처리해야 합니다. 이 방법만이 오래된 Layout과 positioning 변수를 다른 계산에서 사용하는 것을 피할 수 있는 유일한 방법입니다.Automatic refresh triggers뷰의 Layout이 변경되었음을 시스템에 알리는 다음 이벤트들은 개발자가 수동으로 수행하지 않고도 다음 기회에 자동으로 layoutSubviews()가 호출됩니다. 뷰를 Resizing하는 이벤트 Subview 추가하는 이벤트 유저가 UIScrollView를 스크롤하는 이벤트 (UIScrollView와 그것의 Superview의 layoutSubviews() 호출) 디바이스 회전 뷰의 Constraints 변경위의 이벤트들은 모두 뷰의 위치를 다시 계산해야한다는 것을 시스템에 전달하고, 자동으로 최종 layoutSubviews()의 호출로 이어집니다. 하지만 layoutSubviews()를 직접 트리거하는 다음 방법들도 있습니다.setNeedsLayout()setNeedsLayout() 메소드는 layoutSubviews()를 트리거하는 가장 비용이 적은 메소드입니다. 이 메소드는 뷰의 Layout을 다시 계산되어야함을 시스템에 알려줍니다.하지만 setNeedsLayout() 메소드는 즉시 실행되고 반환되지만, 반환되기 전에 뷰를 실제로 업데이트하지는 않습니다. 대신, 시스템이 다음 Update Cycle에서 해당 뷰와 모든 Subview들의 layoutSubviews()를 호출하게 합니다.layoutIfNeeded()layoutIfNeeded() 메소드가 호출되면 뷰의 Layout 업데이트가 필요한 경우 시스템은 즉시 layoutSubviews()를 호출합니다. 하지만 뷰를 업데이트해야하는 경우가 아닐 때에 해당 메소드가 호출될 경우에는 layoutSubviews()가 호출되지 않습니다.(LayoutIfNeeded()가 동일한 Update Cycle동안 두 번 호출될 경우에도 두 번째 호출은 layoutSubviews()를 트리거하지 않음.)layoutIfNeeded() 메소드는 위의 setNeedsLayout() 메소드와는 다르게, 메소드가 반환되기 전에 해당 뷰와 Subview들을 다시 그리고 Layout이 업데이트됩니다. 이 메소드는 다음 Update Cycle까지 기다릴 수 없는 경우(새로운 Layout에 의존해야하는 때)에 유용하지만, 이런 경우가 아니라면 setNeedsLayout() 메소드를 호출해 Run Loop당 한 번 뷰를 업데이트하는 것이 이상적입니다.layoutIfNeeded() 메소드는 Constraints에 대한 변경을 애니메이션하는 상황에서 특히 유용합니다. 애니메이션이 시작되기 전에 모든 Layout 업데이트가 전달되어야 한하는 상황에는 애니메이션 블록이 실행되기 전에 layoutIfNeeded() 메소드를 호출해야 합니다. 새로운 Contraints를 설정하고, 애니메이션 블록 안에서는 또 layoutIfNeeded()를 호출해 애니메이션이 새로운 상태로 진행되도록 해야합니다.참고 자료 [Demystifying iOS Layout]" }, { "title": "CollectionView 안에 CollectionView 넣기 - (2)", "url": "/posts/CollectionViewInCollectionView-2/", "categories": "iOS", "tags": "iOS, CollectionView, dynamic, roundedLabel", "date": "2022-06-27 23:04:00 +0900", "snippet": "(앞서 작성했던 1편에 이어 작성되었습니다.)4. 문제 해결3. IssueCollectionCell의 dynamic height하지만, Issue들 중에 Label을 가지지 않은 Issue들도 있을텐데, 이런 Issue들의 Cell의 높이는 작아져야 하지 않을까? 하는 생각에서 3번째 문제 해결을 해보고자 합니다!현재 상황에서, Label을 가지지 않는 Cell은 다른 Cell들과 높이가 같을 뿐더러, Label이 화면 길이를 넘어가는 만큼 쌓일 경우에는 Label Cell들이 표시되지 않는 문제가 있었습니다.첫 번째 Issue Cell은 5개의 Label Cell은 가진 경우의 모습이고, 네 번째 Issue Cell은 Label Cell을 하나도 가지지 않은 상태입니다.CollectionView에서는 TableView의 UITableViewAutomaticDimension과 같이, cell 안에 들어있는 컨텐츠에 맞춰서 높이를 결정해주는 기능이 없습니다.따라서 DummyCell을 만들어서 미리 사이즈를 결정해준 뒤에, CollectionView의 sizeForItem에서 호출하는 방식이 이용됩니다.이를 이용하기 위해서는, UICollectionViewCell의 사이즈의 결정 시점을 알아야 합니다. 먼저, CollectionView가 그려지려고 할 때, UICollectionViewDataSource의 collectionView(_:numberOfItemsInSection:) 메소드가 호출되어 그려질 섹션에 몇 개의 Cell이 있는지 반환을 요청합니다. 이 때, 반환받은 값이 0이 아니라면, UICollectionViewDelegateFlowLayout에 정의되어 있는 collectionView(_:layout:sizeForItemAt:) 메소드가 호출되어 반환받은 값으로 CollectionViewCell의 사이즈를 결정합니다. 그리고 UICollectionViewDataSource의 collectionView(_:cellForItemAt:) 메소드가 호출되어 위치(indexPath)에 맞는 Cell을 반환받습니다. 먼저, IssueCollectionCell의 Size를 정해주는 collectionView(_:layout:sizeForItemAt:) 메소드에서 Dummy Cell을 생성하여, 들어갈 컨텐츠의 최대 높이를 상정해 넉넉하게 Size를 잡아줍니다. // IssueCollectionViewController.swift\t func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {\t let width = UIScreen.main.bounds.width let estimatedHeight: CGFloat = 200 // &lt;--- 넉넉한 높이를 잡아준다.\t let dummyCell = IssueCollectionCell(frame: CGRect(x: 0, y: 0, width: width, height: estimatedHeight)) ... } 여기서, DummyCell에, 실제로 그 위치의 Cell에 들어갈 데이터를 집어넣어 높이를 구해야 한다. 이를 위해 UICollectionViewDataSource에 있는 실제 Cell에 들어갈 데이터를 받아와야 합니다. DataSource가 나누어져있을 경우 completionHandler를 받는 아래의 메소드를 구현해주도록 합니다. (저는 실습 파일에 작성하여, Delegate, DataSource를 하나의 VC가 모두 담당하게 되어있었습니다.) // IssueCollectionDataSource.swift func referIssue(at indexPath: IndexPath, handler: (Issue) -&gt; Void) { let issue = data[indexPath.item] handler(issue) } 이제 위에서 작성하던 collectionView(_:layout:sizeForItemAt:) 메소드에서 referIssue(at:handler:) 메소드를 사용하는 부분을 추가합니다. // IssueCollectionViewController.swift\t func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { ... dataSource.referIssue(at: indexPath) { (issue) in dummyCell.configure(with: issue) } ... } referIssue(at:handler:) 메소드의 handler에는 IssueCollectionCell의 configure(with:) 메소드를 호출하게 되는데, IssueCollectionCell은 여기서 전달받은 issue를 이용해 정확한 높이를 결정해야 합니다. 이를 위해, IssueCollectionCell(dummyCell)에서는 UI에 필요한 데이터들을 집어넣고, LabelCollectionView.view.reloadData() 메소드를 호출한 후, 결정된 LabelCollectionView를 dummyCell 내의 StackView에 넣어 실제 높이를 계산합니다. 또한, LabelCollectionView가 자기 크기만큼 ContentsStackView 내에 들어가도록 heightAnchor를 지정해줍니다. // IssueCollectionCell.swift\t func configure(with issue: Issue) { titleLabel.text = issue.title data = issue.labels labelCollectionViewController.updateLabels(issue.labels) labelCollectionViewController.reloadCollectionView() contentsStackView.addArrangedSubview(labelCollectionViewController.view)\t layoutIfNeeded() labelCollectionViewController.view.snp.makeConstraints { make in make.height.equalTo(labelCollectionViewController.contentSize.height) } } 여기서 labelCollectionViewController.contentSize.height는 아래와 같이 정의된 computed Property입니다. // LabelCollectionViewController\t var contentSize: CGSize { return labelCollectionView.contentSize } 이제 collectionView(_:layout:sizeForItemAt:) 메서드를 완성할 수 있습니다. 위에서 결정된 값들을 이용해서 EstimatedSize를 결정해줍니다. 이 때, 실제 Issue 데이터를 이용해 실제 길이가 저장된 dummy Cell을 layoutIfNeeded() 메서드와 systemLayoutSizeFitting(_:) 메서드를 사용해 딱 맞는 EstimatedSize를 결정합니다. // IssueCollectionViewController.swift\t func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { ... dummyCell.layoutIfNeeded()\t let estimatedSize = dummyCell.systemLayoutSizeFitting(CGSize(width: width, height: estimatedHeight))\t return CGSize(width: width, height: estimatedSize.height) } 위의 과정을 모두 거쳐 아래와 같은 화면을 드디어 볼 수 있었습니다!4. UILabel의 rounded style다른 프로젝트들을 하면서 궁금했던 점이었는데, 이번 포스팅을 작성하면서 해결한 방법이 있어 문제 해결로 작성합니다!기존에는, Cell의 Height가 얼마나 될지 예상하여 UILabel.layer.cornerRadius를 결정해줬습니다.이번에는 LabelCollectionCell의 Height가 EstimatedSize로 인해 결정되기 때문에 UI가 그려질 때 그에 맞는 높이에 의해 cornerRadius가 결정되도록 하려 했습니다.위의 방법을 구현하기 위해 작성한 코드는 아래와 같습니다.// LabelCollectionCell.swiftfinal class LabelCollectionCell: UICollectionViewCell { ... override func layoutSubviews() { super.layoutSubviews() labelLabel.snp.makeConstraints { make in make.top.leading.equalTo(self) } labelLabel.layer.cornerRadius = labelLabel.frame.height/2 }}layoutSubviews() 메서드는 레이아웃 정보 변경 사항이 뷰에 반영될 때 호출되는데, 이 메서드는 재귀적으로 모든 자식 뷰의 layoutSubviews() 메서드를 호출합니다.(따라서 실행될 시에 부하가 매우 큰 메서드임.)IssueCollectionCell에서 layoutIfNeeds() 메소드가 호출되면layoutSubviews() 가 호출되고,이로 인해 하위 뷰인 LabelCollectionCell의 layoutSubviews() 또한 호출될 것입니다.또한, 이 시점에는 LabelCollectionCell의 Layout들이 모두 잡혀있는 상황이기 때문에, labelLabel의 높이 또한 잡혀있게 됩니다.이 시점에 해당 UILabel의 layer.cornerRadius를 설정해줌으로써 원하는 시점에서 둥근 모양의 Label을 만들 수 있었습니다. 코드 내용은 여기에5. 참고 자료 [ColectionViewCell Dynamic Height] [StackOverflow-Set rounded corner on UIImage in UICollectionViewCell in swift] " }, { "title": "CollectionView 안에 CollectionView 넣기 - (1)", "url": "/posts/CollectionViewInCollectionView-1/", "categories": "iOS", "tags": "iOS, CollectionView, dynamic, String.size", "date": "2022-06-27 21:38:00 +0900", "snippet": "1. 계기코드스쿼드 마지막 팀 프로젝트인 Issue Tracker를 진행하다가, CollectionView(Issue Cell)안에 CollectionView(Label Cell)이 있으면 편하게 구현할 수 있겠다고 생각했습니다.하지만 편할 것이라는 생각과는 다르게, 처음 해보다보니 이 두 CollectionVIew의 DataSource를 관리하는데서 부터 애를 먹기 시작했습니다.이전에 Side Dish같은 프로젝트를 진행할 때에도 왜 CollectionView가 아닌 ScrollView를 사용하려고 하냐는 코드 리뷰를 받았는데, 할 줄 모른다는 핑계를 대신해서 프로젝트 요구사항 을 들먹였던 기억이 떠올라, 이번에는 확실히 짚고 넘어가자고 생각해 정리하려고 합니다.2. 모델링구현해 볼 내용을 간단하게 모델링한 내용은 위와 같습니다. Issue에 해당하는 IssueCollectionView의 Cell 내에 해당 Issue에 속해 있는 Label들을 보여줄 LabelCollectionView가 있는 형태입니다.여기서 사용할 타입은 아래와 같이 정의했습니다.struct Issue {\tlet title: String let labels: [Label]}struct Label { let title: String let backgroundColor: UIColor}IssueCollectionCell에서 사용할 타입은 Issue이고, 이 셀에는 CollectionView가 존재하므로, 해당 CollectionView에서 사용할 데이터([Label])까지 한 번에 받는 것이 핵심입니다.3. 구현1. LabelCollectionCell// LabelCollectionCell.swiftimport SnapKitimport UIKitfinal class LabelCollectionCell: UICollectionViewCell { static let identifier = String(describing: LabelCollectionCell.self) private let labelLabel: PaddingLabel = { let label = PaddingLabel() label.setEdgeInset(top: 4, bottom: 4, left: 16, right: 16) label.translatesAutoresizingMaskIntoConstraints = false return label }() override init(frame: CGRect) { super.init(frame: frame) addSubview(labelLabel) } @available(*, unavailable) required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } func configure(with label: Label) { labelLabel.text = label.title labelLabel.backgroundColor = label.backgroundColor } override func layoutSubviews() { super.layoutSubviews() labelLabel.snp.makeConstraints { make in make.edges.equalTo(self) } }}2. IssueCollectionCell이 Cell에서 LabelCollectionView를 갖고 있게 하기 위해, LabelCollectionViewController를 갖고 있습니다.LabelCollectionView만 가지고 있을 경우, LabelCollectionView에 대한 DataSource, Delegate 모두 해당 Cell에서 담당하게 되는 어색한 상황이 발생했기 때문입니다.// IssueCollectionCell.swiftimport UIKitimport SnapKitfinal class IssueCollectionCell: UICollectionViewCell { static let identifier = String(describing: IssueCollectionCell.self) let contentsStackView: UIStackView = { let stackView = UIStackView() stackView.translatesAutoresizingMaskIntoConstraints = false stackView.axis = .vertical stackView.spacing = 15 return stackView }() private let titleLabel: UILabel = { let label = UILabel() label.numberOfLines = 0 label.font = .systemFont(ofSize: 22) label.translatesAutoresizingMaskIntoConstraints = false label.adjustsFontSizeToFitWidth = true return label }() private let labelCollectionViewController = LabelCollectionViewController() private var data = [Label]() override init(frame: CGRect) { super.init(frame: frame) addSubview(contentsStackView) contentsStackView.addArrangedSubview(titleLabel) contentStackView.addArracgedSubview(labelCollectionViewController.view) clipsToBounds = true } @available(*, unavailable) required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } func configure(with issue: Issue) { titleLabel.text = issue.title data = issue.labels contentsStackView.addArrangedSubview(labelCollectionViewController.view) configureLabels(with: issue) } override func layoutSubviews() { contentsStackView.snp.makeConstraints { make in make.top.bottom.equalTo(self) make.width.equalTo(UIScreen.main.bounds.width * 0.8) make.centerX.equalTo(self) } }}4. 문제 해결1. LabelCollectionCell의 간격 문제LabelCollectionView를 초기화할 때 UICollectionViewFlowLayout을 설정해주면서 UICollectionViewFlowLayout.minimumLineSpacing = 10과 같이 설정을 해주었기 때문에 Cell간 간격이 지정될 것이라고 생각했지만, 제가 원하는 간격이 지정되지 않는 문제가 발생했습니다..🚨 minimumLineSpacing = 10 minimumLineSpacing = 100 minimumLineSpacing 속성을 바꾸어주어도, Cell간 간격에는 달라지는 점이 없었습니다,,여기서 찾은 첫번째 문제는, horizontal 방향으로 스크롤되는 CollectionView의 경우, 셀 간격을 조정하기 위해서는 minimumLineSpacing이 아니라, minimumInteritemSpacing 을 설정해주어야 한다는 것입니다.// final class LabelCollectionView: UICollectionViewconvenience init() { let flowLayout = UICollectionViewFlowLayout() flowLayout.minimumInteritemSpacing = 100 self.init(frame: .zero, collectionViewLayout: flowLayout) ...}작성했던 LabelCollectionView의 설정 값들 중, 위에서 말한 값을 수정해주었더니 아래와 같이 화면이 변경되었습니다!2. LabelCollectionCell의 dynamic width이제, LabelCollectionCell의 width를 글자의 길이에 맞게 dynamic하게 설정하는 과정이 필요합니다.Cell의 Layout을 설정하는 객체는 UICollectionViewDelegate, 여기서 UICollectionViewFlowLayout을 이용하면 된다고 판단했습니다.해당 객체의 collectionView(_: layout: sizeForItemAt:) -&gt; CGSize 메소드를 이용해 Cell의 크기를 지정해줄 수 있습니다.그럼 아직 들어오지 않은 String 값의 width를 어떻게 알 수 있을까요?String.size(withAttribute:) 메소드를 이용해 알 수 있었습니다.String이 들어갈 UI(저는 UILabel의 길이를 구하려고 합니다.)에서 사용하는 Font 속성을 사용해 width를 아래와 같이 구할 수 있습니다.String.size(withAttribute: [NSAttributedString.Key.font: .systemFont(ofSize: 17)])위 코드를 이용해 UICollectionViewDelegateFlowLayout 객체를 완성했습니다.extension IssueCollectionCell: UICollectionViewDelegateFlowLayout { func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { return CGSize(width: data[indexPath.item].title.size(withAttributes: [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 17)]).width + 32, height: 50) }}이제 원하는 화면이 나오는 것을 확인할 수 있었습니다!(길이가 너무 길어져, 2편에서 마저 작성하겠습니다! 2편에는 CollectionView Dynamic Height를 중점으로 작성합니다.)5. 참고 자료 [StackOerflow-Dynamic cell width of UICollectionView depending on label width]" } ]
